#include "FileParser/FileParser.h"
#include "Instrumentor.h"
#include <sstream>
#include <vector>
#include <iostream>
#include <filesystem>
#include <stack>
#include <assert.h>
#include <cstring>
#include <string_view>

namespace Reflect
{
	constexpr int DEFAULT_TYPE_SIZE = 0;

	FileParser::FileParser()
	{ }

	FileParser::~FileParser()
	{ }

	void FileParser::ParseDirectory(const std::string& directory)
	{
		REFLECT_PROFILE_FUNCTION();

		m_filesParsed.clear();
		m_filesToRemove.clear();

		std::filesystem::path dirPath(directory);
		std::error_code err;
		if (!std::filesystem::is_directory(dirPath, err))
		{
			std::cout << err.message() << '\n';
			return;
		}

		for (const auto& f : std::filesystem::recursive_directory_iterator(directory))
		{
			std::string filePath = f.path().string();

			if ((f.is_regular_file() || f.is_character_file()) &&
				CheckExtension(filePath, { ".h", ".hpp", ".hxx"}) &&
				!CheckIfAutoGeneratedFile(filePath))
			{
				// TODO thread this. We could load files on more than one thread to speed
				// this up.
				//std::cout << "Parsing: " << filePath << std::endl;
				std::ifstream file = OpenFile(filePath);
				FileParsedData data = LoadFile(file);
				const auto ext = f.path().filename().string().find_last_of('.');
				data.FileName = f.path().filename().string().substr(0, ext);
				data.FileExtension = f.path().filename().string().substr(ext + 1);
				data.FilePath = f.path().parent_path().string();
				data.SubPath = data.FilePath.substr(directory.length());
				m_filesParsed.push_back(data);
				CloseFile(file);
			}
		}


		// All files have been loaded.
		// Now we need to parse them to find all the information we want from them.
		// TODO this could also be threaded.
		for (auto& file : m_filesParsed)
		{
			if (!ParseFile(file))
			{
				m_filesToRemove.push_back(file.FileName);
			}
		}

		for (auto const& fileToRemove : m_filesToRemove)
		{
			auto itr = std::find_if(m_filesParsed.begin(), m_filesParsed.end(), [fileToRemove](FileParsedData const& data)
			{
				return fileToRemove == data.FileName;
			});
			assert(itr != m_filesParsed.end() && "[FileParser::ParseDirectory] Remove file to parse dose not exists.");
			m_filesParsed.erase(itr);
		}
	}

	std::ifstream FileParser::OpenFile(const std::string& filePath)
	{
		std::ifstream file = std::ifstream(filePath);
		assert(file.is_open() && "[FileParser::OpenFile] File is not open.");
		return file;
	}

	void FileParser::CloseFile(std::ifstream& file)
	{
		if (file.is_open())
		{
			file.close();
		}
	}

	bool FileParser::CheckExtension(const std::string& filePath, std::vector<const char*> extensions)
	{
		const auto dot = filePath.find_last_of('.');
		if (dot == std::string::npos)
		{
			return false;
		}

		std::string extension = filePath.substr(dot);
		for (auto& e : extensions)
		{
			if (e == extension)
			{
				return true;
			}
		}
		return false;
	}

	bool FileParser::CheckIfAutoGeneratedFile(const std::string& filePath)
	{
		return
			filePath.find(ReflectFileGeneratePrefix) != std::string::npos ||
			filePath.find(ReflectStaticFileGeneratePrefix) != std::string::npos;
	}

	FileParsedData FileParser::LoadFile(std::ifstream& file)
	{
		FileParsedData rawData = {};

		file.seekg(0, std::ios::end);
		int fileSize = static_cast<int>(file.tellg());
		file.seekg(0, std::ios::beg);
		rawData.Data = std::string(fileSize, '\0');
		rawData.Cursor = 0;
		file.read(&rawData.Data[0], fileSize);

		//return rawData;

		// Strip out comments.
		FileParsedData cleanedData = {};
		auto idx = rawData.Data.find("//");
		auto lastIdx = 0;
		while (idx != std::string::npos)
		{
			cleanedData.Data.append(rawData.Data, lastIdx, idx - lastIdx);
			idx = rawData.Data.find("\n", idx);
			lastIdx = idx;
			idx = rawData.Data.find("//", idx);
		}
		cleanedData.Data.append(rawData.Data, lastIdx);
		cleanedData.Cursor = 0;

		return cleanedData;
	}

	bool FileParser::ParseFile(FileParsedData& fileData)
	{
		REFLECT_PROFILE_FUNCTION();

		bool reflectItem = false;
		while (ReflectContainerHeader(fileData, RefectEnumKey, ReflectType::Enum) || ReflectContainerHeader(fileData, RefectStructKey, ReflectType::Struct) || ReflectContainerHeader(fileData, RefectClassKey, ReflectType::Class))
		{
			ReflectContainer(fileData);
			reflectItem = true;
		}
		return reflectItem;
	}

	bool FileParser::ReflectContainerHeader(FileParsedData& fileData, const std::string& keyword, const ReflectType type)
	{
		// Check if we can reflect this class/struct. 
		const auto reflectStart = static_cast<int>(fileData.Data.find(keyword, fileData.Cursor));
		if (reflectStart == std::string::npos)
		{
			// Can't reflect this class/struct. Return.
			return false;
		}

		ReflectContainerData containerData = {};

		containerData.ReflectType = type;
		fileData.Cursor = reflectStart + static_cast<int>(keyword.length()) + 1;
		containerData.ContainerProps = ReflectFlags(fileData);

		const char* kw = "";
		if (containerData.ReflectType == ReflectType::Class)
		{
			kw = "class";
		}
		else if (containerData.ReflectType == ReflectType::Struct)
		{
			kw = "struct";
		}
		else if (containerData.ReflectType == ReflectType::Enum)
		{
			// Enums are strongly typed as members of classes.
			kw = "class";
		}
		const auto newPos = (int)fileData.Data.find(kw, fileData.Cursor);
		if (newPos == std::string::npos)
		{
			return false;
		}

		// Parse the template args.
		const auto templatePos = (int)fileData.Data.find("template", fileData.Cursor);
		if (templatePos > reflectStart && templatePos < newPos)
		{
			int templateStack = 0;

			fileData.Cursor = templatePos;
			fileData.Cursor += strlen("template");

			while (fileData.Data.at(fileData.Cursor) != '<') ++fileData.Cursor;
			++fileData.Cursor;
			++templateStack;

			std::string args;

			while (true)
			{
				const auto c = fileData.Data.at(fileData.Cursor);
				++fileData.Cursor;

				templateStack += c == '<';
				templateStack -= c == '>';

				if (!templateStack)
				{
					break;
				}

				args += c;
			}

			containerData.TemplateArgString = args;
			containerData.TemplateArgNames = DetectTemplateArgNames(args);
		}

		fileData.Cursor = newPos;
		fileData.Cursor += strlen(kw);

		// Get the flags passed though the REFLECT macro.
		std::string token, containerName;
		while (fileData.Data.at(fileData.Cursor) != ':' && fileData.Data.at(fileData.Cursor) != '{' && fileData.Data.at(fileData.Cursor) != '\n')
		{
			if (!std::isspace(fileData.Data.at(fileData.Cursor)))
			{
				token += fileData.Data.at(fileData.Cursor);
			}
			else if (token.size())
			{
				// We only want to keep the last token before the ':' or '{'. Consider:
				// class EXPORT Player final { ...
				if (token != "final")
					containerName = std::move(token);
				token.clear();
			}
			++fileData.Cursor;
		}
		containerData.Name = containerName;
		containerData.Type = containerName;
		containerData.TypeSize = DEFAULT_TYPE_SIZE;

		// Assume the first type name found is the super class.
		if (fileData.Data.at(fileData.Cursor) == ':')
		{
			bool inTemplate = false;
			std::string visibility;
			token.clear();
			++fileData.Cursor;
			while (fileData.Data.at(fileData.Cursor) != '{')
			{
				const char ch = fileData.Data.at(fileData.Cursor);
				if (ch == '<')
				{
					inTemplate = true;
				}
				else if (ch == '>')
				{
					inTemplate = false;
				}
				
				if (!std::isspace(ch) || inTemplate)
				{
					token += ch;
				}
				else if (token == "virtual" || token == "public" || token == "protected" || token == "private")
				{
					visibility = token;
					token.clear();
				}
				else if (token.find("REFLECT_BASE()") == 0) // Use find to catch "REFLECT_BASE()," as well.
				{
					containerData.SuperName = Util::GetTypeName<IReflect>();
				}
				else if (token.length())
				{
					if (token.ends_with(','))
						token.erase(token.end() - 1);
					if (!containerData.SuperName.length())
					{
						containerData.SuperName = std::move(token);
					}
					else
					{
						containerData.Interfaces.emplace_back(std::move(token));
					}

					visibility.clear();
					token.clear();
				}
				++fileData.Cursor;
			}
		}

		fileData.ReflectData.push_back(containerData);

		return true;
	}

	void FileParser::ReflectContainer(FileParsedData& fileData)
	{
		int endOfContainerCursor = FindEndOfContainer(fileData);

		// Good, we have a reflected container class/struct.
		// First find out which it is and verify that we are inheriting from "ReflectObject".
		ReflectContainerData& conatinerData = fileData.ReflectData.back();

		if (conatinerData.ReflectType == ReflectType::Struct || conatinerData.ReflectType == ReflectType::Class)
		{
			ReflectClassContainer(fileData, conatinerData, endOfContainerCursor);
		}
		else if (conatinerData.ReflectType == ReflectType::Enum)
		{
			ReflectEnumContainer(fileData, conatinerData, endOfContainerCursor);
		}
	}

	void FileParser::ReflectClassContainer(FileParsedData& fileData, ReflectContainerData& conatinerData, int endOfContainerCursor)
	{
		int generatedBodyLine = static_cast<int>(fileData.Data.find(ReflectGeneratedBodykey, fileData.GeneratedBodyLineOffset));
		assert(generatedBodyLine != -1 && "[FileParser::ReflectClassContainer] 'REFLECT_GENERATED_BODY()' is missing from a container.");
		fileData.GeneratedBodyLineOffset = generatedBodyLine + static_cast<int>(strlen(ReflectGeneratedBodykey));
		conatinerData.ReflectGenerateBodyLine = CountNumberOfSinceTop(fileData, generatedBodyLine, '\n') + 1;

		while (true)
		{
			int reflectStart = static_cast<int>(fileData.Data.find(PropertyKey, fileData.Cursor));
			if (reflectStart == static_cast<int>(std::string::npos) || reflectStart > endOfContainerCursor)
			{
				// There are no more properties to reflect or we have found a new container to reflect.
				break;
			}
			fileData.Cursor = reflectStart + static_cast<int>(strlen(PropertyKey));

			// Get the reflect flags.
			auto propFlags = ReflectFlags(fileData);

			// Get the type and name of the property to reflect.
			auto [type, name, isConst] = ReflectTypeAndName(fileData, {});

			char c = FindNextChar(fileData, { ' ', '\t' });
			while (c != ';' && c != '=' && c != '(' && c != '\n')
			{
				++fileData.Cursor;
				c = FindNextChar(fileData, { ' ', '\t' });
			}

			// Find out if the property is a function or member variable.
			if (c == ';' || c == '=')
			{
				// Member
				// We have found a member variable 
				ReflectMemberData memberData = {};
				memberData.Type = type;
				memberData.Name = name;
				memberData.ReflectMemberType = type.back() == '*' || type.back() == '&' ? (type.back() == '*' ? ReflectMemberType::Pointer : ReflectMemberType::Reference) : ReflectMemberType::Value;
				memberData.TypeSize = DEFAULT_TYPE_SIZE;
				memberData.ContainerProps = propFlags;
				memberData.IsConst = isConst;
				conatinerData.Members.push_back(memberData);
			}
			else if (c == '(')
			{
				ReflectFunctionData funcData = {};
				funcData.Type = type;
				funcData.Name = name;
				funcData.TypeSize = DEFAULT_TYPE_SIZE;
				funcData.ContainerProps = propFlags;
				conatinerData.Functions.push_back(funcData);

				// Function
				ReflectGetFunctionParameters(fileData);
			}
			else if (c == '\n')
			{
				assert(false && "[FileParser::ReflectClassContainer] Unknown reflect type. This must be a member variable or function. Make sure ')' or ';' is used before a new line.");
			}

			++fileData.Cursor;
		}
	}

	void FileParser::ReflectEnumContainer(FileParsedData& fileData, ReflectContainerData& containerData, int endOfContainerCursor)
	{
		using namespace std::literals;

		int generatedBodyLine = static_cast<int>(fileData.Data.find(ReflectGeneratedBodykey, fileData.GeneratedBodyLineOffset));
		assert(generatedBodyLine != -1 && "[FileParser::ReflectEnumContainer] 'REFLECT_GENERATED_BODY()' is missing from a container.");
		fileData.GeneratedBodyLineOffset = generatedBodyLine + static_cast<int>(strlen(ReflectGeneratedBodykey));
		containerData.ReflectGenerateBodyLine = CountNumberOfSinceTop(fileData, generatedBodyLine, '\n') + 1;

		const auto kw = "enum"sv;
		int newPos = (int)fileData.Data.find(kw, fileData.Cursor);
		assert(newPos != std::string::npos && "[FileParser::ReflectEnumContainer] 'enum' is missing from a container.");
		fileData.Cursor = newPos;
		fileData.Cursor += kw.length();

		int64_t value = -1;

		// Consume the opening brace.
		while (fileData.Data[fileData.Cursor++] != '{') {}

		while (true)
		{
			ReflectConstantData constantData = {};
			bool hex = false;

			EatWhitespace(fileData, endOfContainerCursor);

			// Skip commented lines.
			const std::string_view v0(fileData.Data.begin() + fileData.Cursor, fileData.Data.end());
			if (v0.starts_with("//") || v0.starts_with("/*"))
			{
				// Eat everything till the next constant.
				while (fileData.Data[fileData.Cursor] == ',' || fileData.Data[fileData.Cursor] == ';')
				{
					fileData.Cursor++;
					if (fileData.Cursor >= endOfContainerCursor)
					{
						return;
					}
				}
				continue;
			}

			EatWhitespace(fileData, endOfContainerCursor);
			
			const std::string_view v1(fileData.Data.begin() + fileData.Cursor, fileData.Data.end());
			if (v1.starts_with(MetaKey))
			{
				constantData.Name.clear();

				fileData.Cursor += strlen(MetaKey);
				constantData.Flags = ReflectFlags(fileData);
				EatWhitespace(fileData, endOfContainerCursor);
			}

			// Get constant name.
			while (std::isalnum(fileData.Data[fileData.Cursor]) || fileData.Data[fileData.Cursor] == '_' || fileData.Data[fileData.Cursor] == '$')
			{
				constantData.Name += fileData.Data[fileData.Cursor++];
				if (fileData.Cursor >= endOfContainerCursor)
				{
					return;
				}
			}

			EatWhitespace(fileData, endOfContainerCursor);

			// Check for value assignment.
			if (fileData.Data[fileData.Cursor] == '=')
			{
				fileData.Cursor++;

				EatWhitespace(fileData, endOfContainerCursor);

				// Get value.
				std::string num;
				while (std::isdigit(fileData.Data[fileData.Cursor]) || fileData.Data[fileData.Cursor] == 'x')
				{
					if (fileData.Data[fileData.Cursor] == 'x')
					{
						hex = true;
					}

					num += fileData.Data[fileData.Cursor++];
					if (fileData.Cursor >= endOfContainerCursor)
					{
						return;
					}
				}

				value = std::strtoll(num.c_str(), nullptr, hex ? 16 : 10);
			}
			else
			{
				value++;
			}

			EatWhitespace(fileData, endOfContainerCursor);

			constantData.Value = value;
			containerData.Constants.push_back(std::move(constantData));

			// Move to the next token.
			while (!std::isalnum(fileData.Data[fileData.Cursor]) && fileData.Data[fileData.Cursor] != '_' && fileData.Data[fileData.Cursor] != '$')
			{
				fileData.Cursor++;
				if (fileData.Cursor >= endOfContainerCursor)
				{
					return;
				}
			}
		}
	}

	int FileParser::FindEndOfContainer(const FileParsedData& fileData)
	{
		int stack = 0;
		int cursor = fileData.Cursor;
		char lastCharacter = '\0';
		char c = fileData.Data.at(cursor);
		while (true)
		{
			if (c == '{') ++stack;
			if (c == '}') --stack;

			if (!stack && lastCharacter == '}' && c == ';')
			{
				break;
			}

			if (c != '\t' && c != '\n')
			{
				lastCharacter = c;
			}
			++cursor;
			c = fileData.Data.at(cursor);
		}
		return cursor;
	}

	std::vector<std::string> FileParser::ReflectFlags(FileParsedData& fileData)
	{
		// Get the flags passed though the REFLECT macro.
		std::string flag;
		std::vector<std::string> flags;

		EatWhitespace(fileData, fileData.Data.length());

		if (fileData.Data[fileData.Cursor] == '(')
		{
			++fileData.Cursor;
		}

		EatWhitespace(fileData, fileData.Data.length());
		while (fileData.Data[fileData.Cursor] != ')')
		{
			char c = fileData.Data[fileData.Cursor++];
			if (c == ',')
			{
				if (!flag.empty())
				{
					flags.push_back(flag);
				}
				flag = "";
				EatWhitespace(fileData, fileData.Data.length());
			}
			else
			{
				if (c != ' ' && c != '\t' && c != '\r' && c != '\n')
				{
					flag += c;
				}
			}
		}
		++fileData.Cursor;
		if (!flag.empty())
		{
			flags.push_back(flag);
		}

		return flags;
	}

	char FileParser::FindNextChar(FileParsedData& fileData, const std::vector<char>& ingoreChars)
	{
		while (std::find(ingoreChars.begin(), ingoreChars.end(), fileData.Data[fileData.Cursor]) != ingoreChars.end())
		{
			++fileData.Cursor;
		}
		return fileData.Data[fileData.Cursor];
	}

	bool FileParser::RefectCheckForEndOfLine(const FileParsedData& fileData)
	{
		char c = fileData.Data[fileData.Cursor];
		if (std::isspace(c) || c == '(' || c == ';')
		{
			return true;
		}

		return false;
	}

	bool FileParser::ReflectTypeCheck(const std::string& type)
	{
		if (type == "const")
		{
			return true;
		}

		return false;
	}

	void FileParser::ReflectGetFunctionParameters(FileParsedData& fileData)
	{
		fileData.Cursor = static_cast<int>(fileData.Data.find('(', fileData.Cursor));
		++fileData.Cursor;

		ReflectFunctionData& funcData = fileData.ReflectData.back().Functions.back();

		while (fileData.Data[fileData.Cursor] != ')')
		{
			auto [type, name, isConst] = ReflectTypeAndName(fileData, { ',', ')' });
			funcData.Parameters.push_back(
				{
					type,
					name,
					DEFAULT_TYPE_SIZE,
					type.back() == '*' || type.back() == '&' ? (type.back() == '*' ? ReflectMemberType::Pointer : ReflectMemberType::Reference) : ReflectMemberType::Value,
					isConst
				});
		}
	}

	std::tuple<std::string, std::string, bool> FileParser::ReflectTypeAndName(FileParsedData& fileData, const std::vector<char>& endOfLineCharacters)
	{
		std::string type;
		bool typeFound = false;
		std::string name;
		bool nameFound = false;
		bool isConst = false;
		int templateStack = 0;

		while (true)
		{
			char c = fileData.Data[fileData.Cursor];
			if (c == '}')
			{
				// Break here if we have finished
				break;
			}

			if (!templateStack && (RefectCheckForEndOfLine(fileData) || (std::find(endOfLineCharacters.begin(), endOfLineCharacters.end(), c) != endOfLineCharacters.end())))
			{
				if (!typeFound)
				{
					if (!type.empty())
					{
						typeFound = true;
						CheckForConst(fileData, type, typeFound, isConst);
					}
				}
				else if (!nameFound)
				{
					if (!name.empty())
					{
						nameFound = true;
					}
				}
			}
			else if (c != '\n' && c != '\t') /*if ((c >= 'A' && c <= 'Z') || (c >= 'a' && c <= 'z') || c == '_')*/
			{
				// Keep track of if we're in template args. Normally, a space indicates when a type ends and name begins. Consider:
				//	int i;
				// Now consider templates:
				//	std::map<std::string, std::string> m;
				// The space between the template args would then be picked up as delimiting type and name.
				// We don't want that...
				templateStack += c == '<';
				templateStack -= c == '>';

				if (!typeFound)
				{
					type += c;
				}
				else if (!nameFound)
				{
					name += c;
				}
			}

			if ((typeFound && nameFound))
			{
				break;
			}
			++fileData.Cursor;
		}

		// HACK: Scoop up whole name of "operator()". It's skipped above because the loop is (rightfully) programmed to end at the first parenthesis.
		// operator() is an awkward case that's easier to detect at the end.
		if (name == "operator" && std::string_view(fileData.Data.begin() + fileData.Cursor, fileData.Data.begin() + fileData.Cursor + 2) == "()")
		{
			name += "()";
			fileData.Cursor += 2;
		}

		return std::make_tuple<std::string, std::string>(type.c_str(), name.c_str(), isConst);
	}

	void FileParser::CheckForConst(FileParsedData& fileData, std::string& type, bool& typeFound, bool& isConst)
	{
		const int len = 6;
		std::string tmp;
		if (isConst)
		{
			return;
		}

		for (int i = fileData.Cursor - (len - 1); i < fileData.Cursor; ++i)
		{
			if (i < 0)
			{
				break;
			}
			tmp += fileData.Data[i];
		}
		if (tmp == "const")
		{
			type += ' ';
			typeFound = false;
			isConst = true;
			return;
		}

		tmp = "";
		for (int i = fileData.Cursor + 1; i < fileData.Cursor + len; ++i)
		{
			if (i > static_cast<int>(fileData.Data.size()))
			{
				break;
			}
			tmp += fileData.Data[i];
		}
		if (tmp == "const")
		{
			type += ' ' + tmp;
			fileData.Cursor += 5;
			typeFound = false;
			isConst = true;
		}
	}

	int FileParser::CountNumberOfSinceTop(const FileParsedData& fileData, int cursorStart, const char& character)
	{
		int count = 0;
		while (cursorStart > 0)
		{
			//TODO Out of bounds checks.
			if (fileData.Data[cursorStart] == character)
			{
				++count;
			}
			--cursorStart;
		}
		return count;
	}

	void FileParser::EatWhitespace(FileParsedData& fileData, int endOfContainerCursor)
	{
		while (std::isspace(fileData.Data[fileData.Cursor]))
		{
			fileData.Cursor++;
			if (fileData.Cursor >= endOfContainerCursor)
			{
				return;
			}
		}
	}

	std::vector<std::string> FileParser::DetectTemplateArgNames(const std::string& s)
	{
		std::string token;
		std::vector<std::string> n;

		size_t o = 0;
		while (o < s.length())
		{
			if (isspace(s[o]))
			{
				token.clear();
			}
			else if (s[o] == ',')
			{
				n.emplace_back(std::move(token));
				token.clear();
			}
			else
			{
				token += s[o];
			}

			++o;
		}

		n.emplace_back(token);

		return n;
	}
}
